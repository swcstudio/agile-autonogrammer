/**
 * Vulnerability Scanner Component Tests
 * 
 * Comprehensive test suite for the VulnerabilityScanner component
 * Tests Red Team, Purple Team, and Green Hat functionality
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { VulnerabilityScanner } from '../src/components/VulnerabilityScanner';
import { useVulnerabilityScanner } from '../src/hooks/useVulnerabilityScanner';
import type { VulnerabilityReport } from '../src/types';

// Mock the hook
vi.mock('../src/hooks/useVulnerabilityScanner');
const mockUseVulnerabilityScanner = vi.mocked(useVulnerabilityScanner);

// Mock the security store
vi.mock('../src/stores/securityStore', () => ({
  useSecurityStore: () => ({
    addSecurityEvent: vi.fn(),
    updateSecurityMetrics: vi.fn(),
  }),
}));

// Mock Katalyst hooks
vi.mock('@katalyst/hooks', () => ({
  useKatalyst: () => ({
    state: vi.fn((initial) => [initial, vi.fn()]),
    effect: vi.fn(),
    callback: vi.fn((fn) => fn),
  }),
}));

describe('VulnerabilityScanner', () => {
  const mockScan = vi.fn();
  const mockScanFile = vi.fn();
  const mockScanMultiple = vi.fn();
  const mockClearResults = vi.fn();
  const mockClearHistory = vi.fn();
  const mockExportReport = vi.fn();

  const mockVulnerabilityReport: VulnerabilityReport = {
    scanId: 'test-scan-123',
    timestamp: '2024-12-01T10:00:00Z',
    language: 'javascript',
    vulnerabilities: [
      {
        type: 'SQL Injection',
        cwe_id: '89',
        severity: 'Critical',
        lines: [42, 43],
        description: 'Potential SQL injection vulnerability detected',
        poc: 'SELECT * FROM users WHERE id = ' + userInput,
        remediation: 'Use parameterized queries or prepared statements'
      },
      {
        type: 'XSS',
        cwe_id: '79',
        severity: 'High',
        lines: [156],
        description: 'Cross-site scripting vulnerability found',
        poc: 'document.innerHTML = userInput',
        remediation: 'Sanitize user input before rendering'
      }
    ],
    riskScore: 85,
    recommendations: [
      'Implement input validation',
      'Use parameterized queries',
      'Enable content security policy'
    ],
    complianceStatus: {
      compliant: false,
      standards: {
        'PCI-DSS': false,
        'OWASP': false,
        'CWE': true
      }
    }
  };

  beforeEach(() => {
    mockUseVulnerabilityScanner.mockReturnValue({
      scanning: false,
      report: null,
      error: null,
      history: [],
      scan: mockScan,
      scanFile: mockScanFile,
      scanMultiple: mockScanMultiple,
      clearResults: mockClearResults,
      clearHistory: mockClearHistory,
      exportReport: mockExportReport,
      schedulePeriodicScan: vi.fn(() => vi.fn())
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Rendering', () => {
    it('renders the vulnerability scanner interface', () => {
      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('Vulnerability Scanner')).toBeInTheDocument();
      expect(screen.getByText('AI-powered security analysis')).toBeInTheDocument();
      expect(screen.getByPlaceholderText('Paste your code here for security analysis...')).toBeInTheDocument();
      expect(screen.getByText('Scan for Vulnerabilities')).toBeInTheDocument();
    });

    it('shows Red Team, OWASP, and CWE badges', () => {
      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('Red Team')).toBeInTheDocument();
      expect(screen.getByText('OWASP')).toBeInTheDocument();
      expect(screen.getByText('CWE')).toBeInTheDocument();
    });

    it('renders language selection dropdown', () => {
      render(<VulnerabilityScanner />);
      
      const languageSelect = screen.getByDisplayValue('Auto-detect');
      expect(languageSelect).toBeInTheDocument();
      
      // Check some language options
      expect(screen.getByText('JavaScript')).toBeInTheDocument();
      expect(screen.getByText('Python')).toBeInTheDocument();
      expect(screen.getByText('Java')).toBeInTheDocument();
    });
  });

  describe('User Interactions', () => {
    it('updates code input when user types', async () => {
      const user = userEvent.setup();
      render(<VulnerabilityScanner />);
      
      const codeInput = screen.getByPlaceholderText('Paste your code here for security analysis...');
      await user.type(codeInput, 'const test = "vulnerable code";');
      
      expect(codeInput).toHaveValue('const test = "vulnerable code";');
    });

    it('changes language when dropdown is used', async () => {
      const user = userEvent.setup();
      render(<VulnerabilityScanner />);
      
      const languageSelect = screen.getByDisplayValue('Auto-detect');
      await user.selectOptions(languageSelect, 'javascript');
      
      expect(languageSelect).toHaveValue('javascript');
    });

    it('triggers scan when scan button is clicked', async () => {
      const user = userEvent.setup();
      render(<VulnerabilityScanner code="test code" />);
      
      const scanButton = screen.getByText('Scan for Vulnerabilities');
      await user.click(scanButton);
      
      expect(mockScan).toHaveBeenCalledWith('test code', 'auto');
    });

    it('disables scan button when no code is provided', () => {
      render(<VulnerabilityScanner />);
      
      const scanButton = screen.getByText('Scan for Vulnerabilities');
      expect(scanButton).toBeDisabled();
    });

    it('disables scan button during scanning', () => {
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: true,
        report: null,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner code="test code" />);
      
      const scanButton = screen.getByText('Scanning...');
      expect(scanButton).toBeDisabled();
    });
  });

  describe('Scan Results Display', () => {
    it('displays vulnerability summary when scan completes', () => {
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: mockVulnerabilityReport,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('Security Analysis Summary')).toBeInTheDocument();
      expect(screen.getByText('1')).toBeInTheDocument(); // Critical count
      expect(screen.getByText('1')).toBeInTheDocument(); // High count
      expect(screen.getByText('85/100')).toBeInTheDocument(); // Risk score
    });

    it('displays individual vulnerabilities', () => {
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: mockVulnerabilityReport,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('SQL Injection')).toBeInTheDocument();
      expect(screen.getByText('XSS')).toBeInTheDocument();
      expect(screen.getByText('Critical')).toBeInTheDocument();
      expect(screen.getByText('High')).toBeInTheDocument();
    });

    it('displays compliance status', () => {
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: mockVulnerabilityReport,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('PCI-DSS')).toBeInTheDocument();
      expect(screen.getByText('OWASP')).toBeInTheDocument();
      expect(screen.getByText('CWE')).toBeInTheDocument();
    });

    it('displays security recommendations', () => {
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: mockVulnerabilityReport,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('Security Recommendations')).toBeInTheDocument();
      expect(screen.getByText('Implement input validation')).toBeInTheDocument();
      expect(screen.getByText('Use parameterized queries')).toBeInTheDocument();
    });

    it('shows success message when no vulnerabilities found', () => {
      const cleanReport = {
        ...mockVulnerabilityReport,
        vulnerabilities: [],
        riskScore: 0
      };

      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: cleanReport,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('No vulnerabilities detected!')).toBeInTheDocument();
      expect(screen.getByText('Your code passed the security scan.')).toBeInTheDocument();
    });
  });

  describe('Error Handling', () => {
    it('displays error message when scan fails', () => {
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: null,
        error: 'Failed to connect to security service',
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('Scan Error:')).toBeInTheDocument();
      expect(screen.getByText('Failed to connect to security service')).toBeInTheDocument();
    });
  });

  describe('Vulnerability Card Interactions', () => {
    it('expands vulnerability details when clicked', async () => {
      const user = userEvent.setup();
      
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: mockVulnerabilityReport,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      const sqlInjectionCard = screen.getByText('SQL Injection').closest('div');
      expect(sqlInjectionCard).toBeInTheDocument();
      
      // Click to expand
      await user.click(sqlInjectionCard!);
      
      // Should show proof of concept and remediation
      await waitFor(() => {
        expect(screen.getByText('Proof of Concept:')).toBeInTheDocument();
        expect(screen.getByText('Remediation:')).toBeInTheDocument();
      });
    });
  });

  describe('History Management', () => {
    it('displays scan history when available', () => {
      const historyReport = {
        ...mockVulnerabilityReport,
        scanId: 'history-scan-456',
        vulnerabilities: []
      };

      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: null,
        error: null,
        history: [historyReport],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      expect(screen.getByText('Scan History')).toBeInTheDocument();
      expect(screen.getByText('0 issues')).toBeInTheDocument(); // No vulnerabilities in history
    });

    it('clears history when clear button clicked', async () => {
      const user = userEvent.setup();
      
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: null,
        error: null,
        history: [mockVulnerabilityReport],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      const clearButton = screen.getByText('Clear History');
      await user.click(clearButton);
      
      expect(mockClearHistory).toHaveBeenCalled();
    });
  });

  describe('Auto-scan Feature', () => {
    it('triggers auto-scan when enabled and code provided', () => {
      render(<VulnerabilityScanner code="test code" autoScan={true} />);
      
      // Auto-scan should be triggered on mount
      expect(mockScan).toHaveBeenCalledWith('test code', 'auto');
    });

    it('calls onScanComplete callback when scan finishes', () => {
      const mockCallback = vi.fn();
      
      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: mockVulnerabilityReport,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(
        <VulnerabilityScanner 
          code="test code" 
          onScanComplete={mockCallback} 
        />
      );
      
      expect(mockCallback).toHaveBeenCalledWith(mockVulnerabilityReport);
    });
  });

  describe('Theme Support', () => {
    it('applies dark theme by default', () => {
      render(<VulnerabilityScanner />);
      
      const container = screen.getByText('Vulnerability Scanner').closest('div');
      expect(container).toHaveClass('bg-gray-900', 'text-white');
    });

    it('applies light theme when specified', () => {
      render(<VulnerabilityScanner theme="light" />);
      
      const container = screen.getByText('Vulnerability Scanner').closest('div');
      expect(container).toHaveClass('bg-white', 'text-gray-900');
    });
  });

  describe('Accessibility', () => {
    it('has proper ARIA labels', () => {
      render(<VulnerabilityScanner />);
      
      const languageSelect = screen.getByRole('combobox');
      expect(languageSelect).toBeInTheDocument();
      
      const codeInput = screen.getByRole('textbox');
      expect(codeInput).toBeInTheDocument();
      
      const scanButton = screen.getByRole('button', { name: /scan for vulnerabilities/i });
      expect(scanButton).toBeInTheDocument();
    });

    it('supports keyboard navigation', async () => {
      const user = userEvent.setup();
      render(<VulnerabilityScanner code="test code" />);
      
      // Tab through elements
      await user.tab();
      expect(screen.getByRole('combobox')).toHaveFocus();
      
      await user.tab();
      expect(screen.getByRole('button', { name: /expand editor/i })).toHaveFocus();
      
      await user.tab();
      expect(screen.getByRole('button', { name: /scan for vulnerabilities/i })).toHaveFocus();
    });
  });

  describe('Performance', () => {
    it('does not re-render unnecessarily', () => {
      const renderSpy = vi.fn();
      
      const TestComponent = () => {
        renderSpy();
        return <VulnerabilityScanner />;
      };
      
      const { rerender } = render(<TestComponent />);
      
      expect(renderSpy).toHaveBeenCalledTimes(1);
      
      rerender(<TestComponent />);
      expect(renderSpy).toHaveBeenCalledTimes(2);
    });
  });

  describe('Security Features', () => {
    it('validates dangerous code patterns', async () => {
      const user = userEvent.setup();
      const dangerousCode = `
        eval(userInput);
        exec('rm -rf /');
        system('malicious command');
      `;
      
      render(<VulnerabilityScanner />);
      
      const codeInput = screen.getByPlaceholderText('Paste your code here for security analysis...');
      await user.type(codeInput, dangerousCode);
      
      const scanButton = screen.getByText('Scan for Vulnerabilities');
      await user.click(scanButton);
      
      // Should trigger security validation
      expect(mockScan).toHaveBeenCalledWith(dangerousCode, 'auto');
    });

    it('handles XSS prevention in vulnerability display', () => {
      const xssReport = {
        ...mockVulnerabilityReport,
        vulnerabilities: [
          {
            type: 'XSS Test',
            cwe_id: '79',
            severity: 'Critical' as const,
            lines: [1],
            description: '<script>alert("xss")</script>',
            poc: '<img src=x onerror=alert(1)>',
            remediation: 'Sanitize all user inputs'
          }
        ]
      };

      mockUseVulnerabilityScanner.mockReturnValue({
        scanning: false,
        report: xssReport,
        error: null,
        history: [],
        scan: mockScan,
        scanFile: mockScanFile,
        scanMultiple: mockScanMultiple,
        clearResults: mockClearResults,
        clearHistory: mockClearHistory,
        exportReport: mockExportReport,
        schedulePeriodicScan: vi.fn(() => vi.fn())
      });

      render(<VulnerabilityScanner />);
      
      // XSS content should be displayed safely (as text, not executed)
      expect(screen.getByText('XSS Test')).toBeInTheDocument();
      // Script tags should not execute
      expect(document.querySelector('script')).toBeNull();
    });
  });
});