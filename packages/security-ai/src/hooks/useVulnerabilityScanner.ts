/**
 * useVulnerabilityScanner Hook
 * 
 * React hook for AI-powered vulnerability scanning with Katalyst optimizations
 * Supports Red Team operations with real-time threat detection
 */

import { useKatalyst } from '@katalyst/hooks';
import { useSecurityStore } from '../stores/securityStore';
import { SecurityAIClient } from '../client/SecurityAIClient';
import type { VulnerabilityReport, Vulnerability } from '../types';

export interface VulnerabilityScannerState {
  scanning: boolean;
  report: VulnerabilityReport | null;
  error: string | null;
  history: VulnerabilityReport[];
}

export interface VulnerabilityScannerActions {
  scan: (code: string, language?: string) => Promise<VulnerabilityReport>;
  scanFile: (file: File) => Promise<VulnerabilityReport>;
  scanMultiple: (files: { code: string; language: string; path?: string }[]) => Promise<VulnerabilityReport[]>;
  clearResults: () => void;
  clearHistory: () => void;
  exportReport: (format: 'json' | 'pdf' | 'csv') => Promise<Blob>;
  schedulePeriodicScan: (code: string, intervalMinutes: number) => () => void;
}

export type VulnerabilityScannerHook = VulnerabilityScannerState & VulnerabilityScannerActions;

/**
 * Enhanced vulnerability scanner hook with Red Team capabilities
 */
export function useVulnerabilityScanner(): VulnerabilityScannerHook {
  const k = useKatalyst();
  const { securityMetrics, updateSecurityMetrics } = useSecurityStore();
  
  // State management
  const [scanning, setScanning] = k.state(false);
  const [report, setReport] = k.state<VulnerabilityReport | null>(null);
  const [error, setError] = k.state<string | null>(null);
  const [history, setHistory] = k.state<VulnerabilityReport[]>([]);
  const [client] = k.state(() => new SecurityAIClient());
  
  // Load history from localStorage on mount
  k.effect(() => {
    const savedHistory = localStorage.getItem('katalyst-security-history');
    if (savedHistory) {
      try {
        setHistory(JSON.parse(savedHistory));
      } catch (e) {
        console.warn('Failed to load security scan history:', e);
      }
    }
  }, []);
  
  // Save history to localStorage when it changes
  k.effect(() => {
    localStorage.setItem('katalyst-security-history', JSON.stringify(history));
  }, [history]);
  
  // Performance metrics tracking
  const trackScanMetrics = k.callback((
    startTime: number,
    endTime: number,
    vulnerabilities: Vulnerability[]
  ) => {
    const metrics = {
      scanDuration: endTime - startTime,
      vulnerabilitiesFound: vulnerabilities.length,
      criticalCount: vulnerabilities.filter(v => v.severity === 'Critical').length,
      highCount: vulnerabilities.filter(v => v.severity === 'High').length,
      timestamp: Date.now()
    };
    
    updateSecurityMetrics({
      ...securityMetrics,
      totalScans: (securityMetrics?.totalScans || 0) + 1,
      totalVulnerabilities: (securityMetrics?.totalVulnerabilities || 0) + vulnerabilities.length,
      averageScanTime: metrics.scanDuration,
      lastScan: metrics.timestamp
    });
  }, [securityMetrics, updateSecurityMetrics]);
  
  // Main scan function
  const scan = k.callback(async (code: string, language = 'auto'): Promise<VulnerabilityReport> => {
    if (!code.trim()) {
      throw new Error('Code is required for scanning');
    }
    
    setScanning(true);
    setError(null);
    
    const startTime = performance.now();
    
    try {
      // Enhanced input validation for Red Team testing
      const validatedInput = validateAndSanitizeInput(code, language);
      
      // Perform AI-powered vulnerability scan
      const scanResult = await client.scanVulnerabilities({
        code: validatedInput.code,
        language: validatedInput.language,
        options: {
          includeProofOfConcept: true,
          enableRedTeamChecks: true,
          complianceStandards: ['OWASP', 'CWE', 'PCI-DSS', 'HIPAA', 'SOC2'],
          severityThreshold: 'Low'
        }
      });
      
      const endTime = performance.now();
      
      // Add scan metadata
      const enhancedReport: VulnerabilityReport = {
        ...scanResult,
        scanMetadata: {
          scanDuration: endTime - startTime,
          timestamp: new Date().toISOString(),
          katalystVersion: '1.0.0',
          aiModel: 'qwen-coder-32b',
          redTeamMode: true
        }
      };
      
      // Track performance metrics
      trackScanMetrics(startTime, endTime, enhancedReport.vulnerabilities);
      
      // Update state
      setReport(enhancedReport);
      setHistory(prev => [enhancedReport, ...prev.slice(0, 19)]); // Keep last 20 scans
      
      // Log security event
      logSecurityEvent('vulnerability_scan_completed', {
        vulnerabilityCount: enhancedReport.vulnerabilities.length,
        riskScore: enhancedReport.riskScore,
        language: enhancedReport.language
      });
      
      return enhancedReport;
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown scanning error';
      setError(errorMessage);
      
      logSecurityEvent('vulnerability_scan_failed', {
        error: errorMessage,
        language,
        codeLength: code.length
      });
      
      throw err;
    } finally {
      setScanning(false);
    }
  }, [client, trackScanMetrics]);
  
  // Scan file function
  const scanFile = k.callback(async (file: File): Promise<VulnerabilityReport> => {
    const code = await readFileAsText(file);
    const language = detectLanguageFromFilename(file.name);
    return scan(code, language);
  }, [scan]);
  
  // Scan multiple files function
  const scanMultiple = k.callback(async (
    files: { code: string; language: string; path?: string }[]
  ): Promise<VulnerabilityReport[]> => {
    setScanning(true);
    setError(null);
    
    try {
      const results = await Promise.all(
        files.map(async (file, index) => {
          try {
            return await scan(file.code, file.language);
          } catch (err) {
            console.error(`Failed to scan file ${file.path || index}:`, err);
            throw err;
          }
        })
      );
      
      // Aggregate results for comprehensive report
      const aggregatedReport = aggregateMultipleScanResults(results);
      setReport(aggregatedReport);
      
      return results;
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Multiple scan error';
      setError(errorMessage);
      throw err;
    } finally {
      setScanning(false);
    }
  }, [scan]);
  
  // Clear results
  const clearResults = k.callback(() => {
    setReport(null);
    setError(null);
  }, []);
  
  // Clear history
  const clearHistory = k.callback(() => {
    setHistory([]);
    localStorage.removeItem('katalyst-security-history');
  }, []);
  
  // Export report
  const exportReport = k.callback(async (format: 'json' | 'pdf' | 'csv'): Promise<Blob> => {
    if (!report) {
      throw new Error('No scan report available to export');
    }
    
    switch (format) {
      case 'json':
        return new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
        
      case 'csv':
        const csvContent = generateCSVReport(report);
        return new Blob([csvContent], { type: 'text/csv' });
        
      case 'pdf':
        // In a real implementation, you'd use a PDF library like jsPDF
        const pdfContent = await generatePDFReport(report);
        return new Blob([pdfContent], { type: 'application/pdf' });
        
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }, [report]);
  
  // Schedule periodic scanning
  const schedulePeriodicScan = k.callback((
    code: string,
    intervalMinutes: number
  ): (() => void) => {
    const intervalId = setInterval(async () => {
      try {
        await scan(code);
      } catch (err) {
        console.error('Scheduled scan failed:', err);
      }
    }, intervalMinutes * 60 * 1000);
    
    // Return cleanup function
    return () => clearInterval(intervalId);
  }, [scan]);
  
  return {
    // State
    scanning,
    report,
    error,
    history,
    
    // Actions
    scan,
    scanFile,
    scanMultiple,
    clearResults,
    clearHistory,
    exportReport,
    schedulePeriodicScan
  };
}

// Helper functions

function validateAndSanitizeInput(code: string, language: string) {
  // Red Team validation: Check for potentially dangerous patterns
  const dangerousPatterns = [
    /eval\s*\(/gi,
    /exec\s*\(/gi,
    /system\s*\(/gi,
    /__import__\s*\(/gi,
    /document\.write\s*\(/gi
  ];
  
  let securityWarnings: string[] = [];
  
  for (const pattern of dangerousPatterns) {
    if (pattern.test(code)) {
      securityWarnings.push(`Potentially dangerous pattern detected: ${pattern.source}`);
    }
  }
  
  // Log security warnings for audit trail
  if (securityWarnings.length > 0) {
    logSecurityEvent('dangerous_code_patterns_detected', {
      warnings: securityWarnings,
      codeLength: code.length
    });
  }
  
  // Sanitize and validate language
  const validLanguages = [
    'javascript', 'typescript', 'python', 'java', 'csharp', 'go', 
    'rust', 'php', 'ruby', 'cpp', 'swift', 'kotlin', 'scala'
  ];
  
  const sanitizedLanguage = validLanguages.includes(language.toLowerCase()) 
    ? language.toLowerCase() 
    : 'auto';
  
  return {
    code: code.trim(),
    language: sanitizedLanguage,
    securityWarnings
  };
}

function detectLanguageFromFilename(filename: string): string {
  const extensions: Record<string, string> = {
    '.js': 'javascript',
    '.mjs': 'javascript',
    '.ts': 'typescript',
    '.tsx': 'typescript',
    '.jsx': 'javascript',
    '.py': 'python',
    '.java': 'java',
    '.cs': 'csharp',
    '.go': 'go',
    '.rs': 'rust',
    '.php': 'php',
    '.rb': 'ruby',
    '.cpp': 'cpp',
    '.cxx': 'cpp',
    '.cc': 'cpp',
    '.c': 'c',
    '.swift': 'swift',
    '.kt': 'kotlin',
    '.scala': 'scala'
  };
  
  const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
  return extensions[ext] || 'auto';
}

async function readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsText(file);
  });
}

function aggregateMultipleScanResults(results: VulnerabilityReport[]): VulnerabilityReport {
  const allVulnerabilities = results.flatMap(r => r.vulnerabilities);
  const totalRiskScore = results.reduce((sum, r) => sum + r.riskScore, 0) / results.length;
  
  return {
    scanId: crypto.randomUUID(),
    timestamp: new Date().toISOString(),
    language: 'multi',
    vulnerabilities: allVulnerabilities,
    riskScore: Math.round(totalRiskScore),
    recommendations: results.flatMap(r => r.recommendations),
    complianceStatus: {
      compliant: results.every(r => r.complianceStatus.compliant),
      standards: results.reduce((acc, r) => {
        Object.entries(r.complianceStatus.standards).forEach(([key, value]) => {
          acc[key] = (acc[key] ?? true) && value;
        });
        return acc;
      }, {} as Record<string, boolean>)
    }
  };
}

function generateCSVReport(report: VulnerabilityReport): string {
  const headers = ['Type', 'Severity', 'CWE ID', 'Lines', 'Description', 'Remediation'];
  const rows = report.vulnerabilities.map(vuln => [
    vuln.type,
    vuln.severity,
    vuln.cwe_id,
    vuln.lines.join(';'),
    vuln.description.replace(/,/g, ';'),
    vuln.remediation.replace(/,/g, ';')
  ]);
  
  return [
    headers.join(','),
    ...rows.map(row => row.join(','))
  ].join('\n');
}

async function generatePDFReport(report: VulnerabilityReport): Promise<string> {
  // Mock PDF generation - in real implementation use jsPDF or similar
  return `PDF Report for Scan ${report.scanId}\nGenerated: ${report.timestamp}\nVulnerabilities: ${report.vulnerabilities.length}`;
}

function logSecurityEvent(event: string, data: any): void {
  // Security event logging for audit trail
  const logEntry = {
    event,
    data,
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    sessionId: crypto.randomUUID()
  };
  
  // Log to console for development
  console.log('[Katalyst Security Event]', logEntry);
  
  // In production, send to security monitoring service
  if (typeof window !== 'undefined' && (window as any).katalystSecurity) {
    (window as any).katalystSecurity.log(logEntry);
  }
}