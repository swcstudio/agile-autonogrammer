/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Barrier {
  constructor(n: number)
  wait(): boolean
}

export declare class BumpAllocator {
  constructor()
  static withCapacity(capacity: number): BumpAllocator
  allocString(value: string): void
  allocBytes(size: number): void
  allocatedBytes(): number
  reset(): void
  chunkCapacity(): number
}

export declare class CrossbeamArrayQueue {
  constructor(capacity: number)
  push(item: string): boolean
  pop(): string | null
  isEmpty(): boolean
  isFull(): boolean
  len(): number
  capacity(): number
}

export declare class CrossbeamAtomicCell {
  constructor(initialValue: number)
  load(): number
  store(value: number): void
  swap(value: number): number
  compareExchange(current: number, new: number): boolean
  fetchAdd(value: number): number
  fetchSub(value: number): number
}

export declare class CrossbeamChannel {
  constructor(bounded?: number | undefined | null)
  send(message: string): boolean
  receive(): string | null
  isEmpty(): boolean
  len(): number
}

export declare class CrossbeamSegQueue {
  constructor()
  push(item: string): void
  pop(): string | null
  isEmpty(): boolean
  len(): number
}

export declare class DashMap {
  constructor()
  static withCapacity(capacity: number): DashMap
  insert(key: string, value: string): string | null
  get(key: string): string | null
  remove(key: string): string | null
  containsKey(key: string): boolean
  len(): number
  isEmpty(): boolean
  clear(): void
  getOrInsert(key: string, defaultValue: string): string
  update(key: string, updater: string): boolean
  keys(): Array<string>
  values(): Array<string>
  entries(): Array<Array<string>>
  retain(predicateKey: string): void
  shrinkToFit(): void
}

export declare class DashSet {
  constructor()
  insert(value: string): boolean
  remove(value: string): boolean
  contains(value: string): boolean
  len(): number
  isEmpty(): boolean
  clear(): void
  toVec(): Array<string>
}

export declare class FairMutexWrapper {
  constructor(initialValue: string)
  lock(): string
  tryLock(): string | null
  set(value: string): void
  isLocked(): boolean
}

export declare class FlumeChannel {
  constructor()
  static bounded(capacity: number): FlumeChannel
  send(message: string): void
  trySend(message: string): boolean
  sendAsync(message: string): Promise<void>
  recv(): string | null
  tryRecv(): string | null
  recvAsync(): Promise<string | null>
  recvTimeout(timeoutMs: number): string | null
  len(): number
  isEmpty(): boolean
  isFull(): boolean
  capacity(): number | null
  senderCount(): number
  receiverCount(): number
  drain(): Array<string>
  cloneSender(): FlumeSender
  cloneReceiver(): FlumeReceiver
}

export declare class FlumeReceiver {
  recv(): string | null
  tryRecv(): string | null
  recvAsync(): Promise<string | null>
  recvTimeout(timeoutMs: number): string | null
  isDisconnected(): boolean
  len(): number
  isEmpty(): boolean
  drain(): Array<string>
}

export declare class FlumeSelector {
  constructor()
  addReceiver(receiver: FlumeReceiver): void
  select(): SelectResult | null
  trySelect(): SelectResult | null
}

export declare class FlumeSender {
  send(message: string): void
  trySend(message: string): boolean
  sendAsync(message: string): Promise<void>
  isDisconnected(): boolean
  senderCount(): number
}

export declare class MemoryMappedFile {
  static openRead(path: string): MemoryMappedFile
  static openWrite(path: string, size: number): MemoryMappedFile
  read(offset: number, length: number): Array<number>
  readString(offset: number, length: number): string
  write(offset: number, data: Array<number>): void
  writeString(offset: number, data: string): void
  flush(): void
  size(): number
  path(): string
}

export declare class MemoryPool {
  constructor(blockSize: number, initialBlocks: number)
  allocate(): number
  deallocate(blockId: number): void
  write(blockId: number, offset: number, data: Array<number>): void
  read(blockId: number, offset: number, length: number): Array<number>
  blockSize(): number
  totalBlocks(): number
  freeBlocks(): number
  usedBlocks(): number
}

export declare class MultithreadingManager {
  constructor()
  initializeRayon(config?: RayonConfig | undefined | null): void
  initializeTokio(config?: TokioRuntimeConfig | undefined | null): void
  getRayonPool(): boolean
  getTokioRuntime(): boolean
  isRayonInitialized(): boolean
  isTokioInitialized(): boolean
  cleanup(): void
}

export declare class Mutex {
  constructor(initialValue: string)
  lock(): string
  tryLock(): string | null
  lockTimeout(timeoutMs: number): string | null
  set(value: string): void
  isLocked(): boolean
}

export declare class OnceCell {
  constructor()
  get(): string | null
  set(value: string): boolean
  getOrInit(initValue: string): string
  isInitialized(): boolean
}

export declare class RayonThreadPool {
  constructor(config?: RayonConfig | undefined | null)
  currentNumThreads(): number
}

export declare class RwLock {
  constructor(initialValue: string)
  read(): string
  write(value: string): void
  tryRead(): string | null
  tryWrite(value: string): boolean
  readTimeout(timeoutMs: number): string | null
  writeTimeout(value: string, timeoutMs: number): boolean
  readerCount(): number
  isLocked(): boolean
  isLockedExclusive(): boolean
}

export declare class Semaphore {
  constructor(permits: number)
  acquire(): Promise<void>
  tryAcquire(): boolean
  availablePermits(): number
  release(n: number): void
}

export declare class ShardedMap {
  constructor(shardCount: number)
  insert(key: string, value: string): string | null
  get(key: string): string | null
  remove(key: string): string | null
  containsKey(key: string): boolean
  len(): number
  clear(): void
}

export declare class SimdF32X4 {
  constructor(a: number, b: number, c: number, d: number)
  static fromArray(values: Array<number>): SimdF32X4
  add(other: SimdF32X4): SimdF32X4
  sub(other: SimdF32X4): SimdF32X4
  mul(other: SimdF32X4): SimdF32X4
  div(other: SimdF32X4): SimdF32X4
  dot(other: SimdF32X4): number
  sqrt(): SimdF32X4
  abs(): SimdF32X4
  min(other: SimdF32X4): SimdF32X4
  max(other: SimdF32X4): SimdF32X4
  toArray(): Array<number>
  sum(): number
  horizontalSum(): number
}
export type SimdF32x4 = SimdF32X4

export declare class SimdF32X8 {
  constructor(values: Array<number>)
  add(other: SimdF32X8): SimdF32X8
  mul(other: SimdF32X8): SimdF32X8
  toArray(): Array<number>
  sum(): number
}
export type SimdF32x8 = SimdF32X8

export declare class SimdMatrix {
  constructor(rows: number, cols: number)
  static fromVec(rows: number, cols: number, values: Array<number>): SimdMatrix
  add(other: SimdMatrix): SimdMatrix
  mul(other: SimdMatrix): SimdMatrix
  transpose(): SimdMatrix
  scale(scalar: number): SimdMatrix
  rows(): number
  cols(): number
  get(row: number, col: number): number
  set(row: number, col: number, value: number): void
  toVec(): Array<number>
}

export declare class ThreadId {
  static current(): ThreadId
  getId(): string
  static getName(): string | null
  static setName(name: string): void
}

export declare class ThreadLocalCounter {
  constructor(initialValue: number)
  get(): number
  increment(): number
  decrement(): number
  add(amount: number): number
  reset(): void
  getAllValues(): Array<number>
  sumAll(): number
}

export declare class ThreadLocalMap {
  constructor()
  get(key: string): string | null
  set(key: string, value: string): void
  remove(key: string): string | null
  containsKey(key: string): boolean
  keys(): Array<string>
  values(): Array<string>
  clear(): void
  len(): number
}

export declare class ThreadLocalStorage {
  constructor(defaultValue: string)
  get(): string
  set(value: string): void
  update(updater: string): string
  clear(): void
  iterValues(): Array<string>
}

export declare class TokioBroadcastChannel {
  constructor(capacity: number)
  send(message: string): number
  receiverCount(): number
}

export declare class TokioMpscChannel {
  constructor()
}

export declare class TokioRuntime {
  constructor(config?: TokioRuntimeConfig | undefined | null)
}

export declare class TokioTimer {
  constructor()
  elapsedMs(): number
  reset(): void
}

export declare function benchmarkParallelOperations(dataSize: number, operation: string): Promise<unknown>

export interface BenchmarkResult {
  operation: string
  dataSize: number
  result: number
  durationMs: number
  throughput: number
}

export declare function createBarrier(n: number): Barrier

export declare function createBumpAllocator(): BumpAllocator

export declare function createCrossbeamArrayQueue(capacity: number): CrossbeamArrayQueue

export declare function createCrossbeamAtomicCell(initialValue: number): CrossbeamAtomicCell

export declare function createCrossbeamChannel(bounded?: number | undefined | null): CrossbeamChannel

export declare function createCrossbeamSegQueue(): CrossbeamSegQueue

export declare function createDashmap(): DashMap

export declare function createDashmapWithCapacity(capacity: number): DashMap

export declare function createDashset(): DashSet

export declare function createFairMutex(initialValue: string): FairMutexWrapper

export declare function createFlumeBounded(capacity: number): FlumeChannel

export declare function createFlumeSelector(): FlumeSelector

export declare function createFlumeUnbounded(): FlumeChannel

export declare function createMemoryPool(blockSize: number, initialBlocks: number): MemoryPool

export declare function createOnceCell(): OnceCell

export declare function createParkingLotMutex(initialValue: string): any

export declare function createParkingLotRwlock(initialValue: string): RwLock

export declare function createRayonThreadPool(config?: RayonConfig | undefined | null): RayonThreadPool

export declare function createSemaphore(permits: number): Semaphore

export declare function createShardedMap(shardCount: number): ShardedMap

export declare function createSimdF32X4(a: number, b: number, c: number, d: number): SimdF32X4

export declare function createSimdMatrix(rows: number, cols: number): SimdMatrix

export declare function createThreadLocalCounter(initialValue: number): ThreadLocalCounter

export declare function createThreadLocalMap(): ThreadLocalMap

export declare function createThreadLocalStorage(defaultValue: string): ThreadLocalStorage

export declare function createTokioBroadcastChannel(capacity: number): TokioBroadcastChannel

export declare function createTokioMpscChannel(): TokioMpscChannel

export declare function createTokioRuntime(config?: TokioRuntimeConfig | undefined | null): TokioRuntime

export declare function createTokioTimer(): TokioTimer

export declare function getAllThreadNames(): Array<Array<string>>

export declare function getMultithreadingInfo(): string

export declare function getPerformanceMetrics(): PerformanceMetrics

export declare function getRayonGlobalThreadCount(): number

export declare function getSystemInfo(): SystemInfo

export declare function getTokioRuntimeMetrics(): string

export declare function initializeMultithreading(): string

export declare function parallelChunkProcess(data: Array<number>, chunkSize: number, operation: string, pool?: RayonThreadPool | undefined | null): Promise<unknown>

export declare function parallelFilter(data: Array<number>, operation: string, threshold?: number | undefined | null, pool?: RayonThreadPool | undefined | null): Promise<unknown>

export declare function parallelMap(data: Array<number>, operation: string, pool?: RayonThreadPool | undefined | null): Promise<unknown>

export declare function parallelReduce(data: Array<number>, operation: string, initial?: number | undefined | null, pool?: RayonThreadPool | undefined | null): Promise<unknown>

export declare function parallelSort(data: Array<number>, descending?: boolean | undefined | null, pool?: RayonThreadPool | undefined | null): Promise<unknown>

export interface PerformanceMetrics {
  cpuCores: number
  rayonThreads: number
  memoryUsageMb: number
  uptimeMs: number
  activeTasks: number
}

export interface RayonConfig {
  numThreads?: number
  threadName?: string
  stackSize?: number
  panicHandler?: boolean
}

export declare function registerCurrentThread(name: string): void

export interface SelectResult {
  channelIndex: number
  message: string
}

export declare function shutdownMultithreading(): string

export declare function simdDotProduct(a: Array<number>, b: Array<number>): number

export declare function simdParallelSum(data: Array<number>): number

export declare function simdVectorAdd(a: Array<number>, b: Array<number>): Array<number>

export declare function simdVectorScale(vec: Array<number>, scalar: number): Array<number>

export declare function stressTestConcurrency(numTasks: number, taskDurationMs: number, callback: ((err: Error | null, arg: StressTestResult) => any)): void

export interface StressTestResult {
  taskId: number
  durationMs: number
  threadId: string
  status: string
}

export interface SystemInfo {
  cpuCores: number
  rayonThreads: number
  tokioAvailable: boolean
  crossbeamAvailable: boolean
  version: string
}

export declare function tokioDelay(durationMs: number, message: string): Promise<unknown>

export declare function tokioParallelTasks(tasks: Array<string>, delayMs: number): Promise<unknown>

export interface TokioRuntimeConfig {
  workerThreads?: number
  maxBlockingThreads?: number
  threadName?: string
  threadStackSize?: number
  enableIo?: boolean
  enableTime?: boolean
}

export declare function tokioTimeout(durationMs: number, timeoutMs: number, operation: string): Promise<unknown>

export declare function unregisterCurrentThread(): void
